---
title: "Examen de estadística multivariable"
author: "Luis Enrique García Gómez y Sergio Eduardo Rodríguez Tinoco"
output: html_notebook
---
<center> <h1> Análisis estadístico multivariado de los pokemon hasta 8tava generación </h1> </center>

### Introducción:

### Objetivo:

### Métodos:

La base de datos original está disponible en <https://www.kaggle.com/brendan45774/pokmon-index-database?select=pokemon.csv>.

Importar datos y filtrar para obtener una base de datos de 7 variables cuantitativas y dos categóricas (en total son 22 registros después de filtrar).

Pokémons con un total de puntos mayor a 550 y puntos de salud mayores a 100.

### Paqueterias con utilizadas:

Si existe problemas con la instalacion de la paquetería ggalt se recomienda consultar: <https://community.rstudio.com/t/install-ggalt-from-github-without-installing-proj4/35260>

Cargamos los datos originales y realizamos una limpieza de los mismos.
```{r}
pokemon <- read.csv("pokemon.csv")
library(dplyr)
pok<-pokemon%>%
  filter(Total>550, HP>100)%>%
  select(Name:Speed)%>%
  distinct(Name, .keep_all = TRUE)
pok
```
### Estadística descriptiva.

#### Medidas de tendencia central, cuartiles y medidas de dispersión

```{r}
stdev<-pok%>%summarise(sd(Total), sd(HP), sd(Attack), sd(Defense), sd(Special.Attack), sd(Special.Defense), sd(Speed))
names(stdev)<-names(pok[,3:9])
varianza<-stdev^2
```

```{r}
summary(pok[,3:9])
```
Varianza
```{r}
varianza
```
Desviación estándar

```{r}
stdev
```


#### Estandarización porque se desconoce si las variables están en la misma escala

```{r}
pok.scale<-scale(pok[,3:9])
pok.scale<-as.data.frame(pok.scale)
```


#### Medidas de tendencia central y cuartiles con los datos estandarizados

```{r}
summary(pok.scale)
```
#### Gráficas de caja y bigotes

```{r}
boxplot(pok.scale$Total, pok.scale$HP, pok.scale$Attack, pok.scale$Defense, pok.scale$Special.Attack,
        pok.scale$Special.Defense, pok.scale$Speed, names = names(pok.scale))
```

### Observaciones:

- Total tiene datos atípicos y está sesgada a la izquierda.
- HP está sesgada a la derecha.
- Attack y Deffense parecen ser distribuciones normales.
- Special.Attack tiene un dato atípico, Special.Defense parece tener un sesgo a la derecha y Speed tiene tres datos atípicos.
- Las medianas de todas las variables en general no parecen ser diferentes entre si (esto puede comprobarse con otro análisis).



### Pruebas para elegir el tipo de análisis multivariable

#### Pruebas de normalidad

```{r}
shapiro.test(pok.scale$Total)
shapiro.test(pok.scale$HP)
shapiro.test(pok.scale$Attack)
shapiro.test(pok.scale$Defense)
shapiro.test(pok.scale$Special.Attack)
shapiro.test(pok.scale$Special.Defense)
shapiro.test(pok.scale$Speed)
```
Los datos de Total, HP, Special.Defense y Speed no se distribuyen normalmente por lo que los análisis serán no paramétricos.

### Correlación (Kendall)

```{r}
mat_cor<-cor(x=pok.scale, method="kendall")
mat_cor
```

```{r}
library(corrplot)
corrplot(mat_cor, method="ellipse", type="upper")
```
Total, Attack, Special.Attack y Speed están correlacionados positivamente entre sí, por lo que estas variables pueden servir para hacer un análisis de clusters.

```{r}
pok.scale.2 <- pok.scale%>%select(Total, Attack, Special.Attack, Speed)
mat_cor2<-cor(pok.scale.2, method="kendall" )
corrplot(mat_cor2, method = "ellipse", type = "upper")
```

### Visualización de los datos 

```{r}
library(ggplot2)
```

Estandarizados
```{r}
ggplot(pok.scale.2,aes(Attack, Total, color=Special.Attack, size=Speed))+geom_point()
```
Sin estandarizar

```{r}
ggplot(pok,aes(Attack, Total, color=Special.Attack, size=Speed))+geom_point()
```
### Analisis de Clúster
```{r}
# Cluster
pokCluster<-scale(pok[,4:9])
rownames(pokCluster) <- pok$Name
#calcular la matriz de distacias
m.distancia <- get_dist(pokCluster, method =  "euclidean")
#el método aceptado también puede ser: "maximum", "manhattan", "canberra", "binary", "minkowski", "pearson", "spearman" o "kendall"
fviz_dist(m.distancia, gradient = list(low = "blue", mid = "white", high = "red"))
```
### Estimar el número de clústers

Para calcular el número optimo de clústers usaremos varios metodos para tomar dicha decision.

#### Metodo con suma de cuadrados (Elbow)
```{r}
# (apunta a 3 clusters, con la "rodilla o punto de corte)
fviz_nbclust(pokCluster, kmeans, method = "wss")
```
#### Metodo de la silueta.
```{r}
# Metodo de la silueta
# (apunta a 9 clusters y seguido de 3)
fviz_nbclust(pokCluster, kmeans, method = "silhouette")
```
### Metodo estadistico Gap
```{r}
# Gap statistic for hierarchical clustering
fviz_nbclust(pokCluster, kmeans, method = "gap_stat")
```
```{r}
#Con esta función se pueden calcular:
#the index to be calculated. This should be one of : "kl", "ch", "hartigan", "ccc", "scott",
#"marriot", "trcovw", "tracew", "friedman", "rubin", "cindex", "db", "silhouette", "duda",
#"pseudot2", "beale", "ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma",
#"gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw", "all" (all indices except GAP,
#Gamma, Gplus and Tau), "alllong" (all indices with Gap, Gamma, Gplus and Tau included).
pokCluster<-as.data.frame(pokCluster)
resnumclust <- NbClust(pokCluster, distance = "euclidean", min.nc=2, max.nc=10, method = "kmeans", index = "alllong")
fviz_nbclust(resnumclust)

```
Con esta informacion, junto con todos los graficos con su respectivo metodo, se optara por elegir 3 clusters.

### calculamos los tres clústers

```{r}
#calculamos los tres clústers
k3 <- kmeans(pokCluster, centers = 3, nstart = 25)
k3
str(k3)

fviz_cluster(k3, data = pokCluster)
fviz_cluster(k3, data = pokCluster, ellipse.type = "euclid",repel = TRUE,star.plot = TRUE) #ellipse.type= "t", "norm", "euclid"
```
```{r}
# Realizar un endograma
res3 <- hcut(pokCluster, k = 3, stand = TRUE)
fviz_dend(res3, rect = TRUE, cex = 0.5,k_colors = c(1:3))
```

```{r}
# Informacion medias por cluster no estandarizados 
pok[,3:9] %>%
    mutate(Cluster = k3$cluster) %>%
    group_by(Cluster) %>%
    summarise_all("mean")

# Informacion medias por cluster estandarizados 
pokCluster %>%
    mutate(Cluster = k3$cluster) %>%
    group_by(Cluster) %>%
    summarise_all("mean")
```

```{r}
#  Vizualizacion con datos alargados y usando los Closter creados
pokCluster$clus<-factor(pokCluster$clus)
data_long <- gather(pokCluster, caracteristica, valor, HP:Speed, factor_key=TRUE)
data_long

ggplot(data_long, aes(as.factor(x = caracteristica), y = valor,group=clus, colour = clus)) + 
    stat_summary(fun = mean, geom="pointrange", size = 1)+
    stat_summary(geom="line") +
    geom_point(aes(shape=clus))
```
### Clúster jerárquico

Usando distancias euclideanas y método de medias

```{r}
dpok2<-dist(pok.scale.2, method = "euclidean")
clusterpok2<-hclust(dpok2, method = "average")
plot(clusterpok2, labels=pok[,1])
```

### Visualización de datos y clusters (dependiendo de dónde se corte el dendrograma será el número de clusters)


```{r}
library(ggalt) #para encerrar los puntos con geom_encircle()
library(ggrepel) #para poner etiquetas con geom_label_repel()

#cortar el dendrograma
asignaciones<-cutree(clusterpok2, h=2.6)
pok.clustered<- pok%>%select(Total, Attack, Special.Attack, Speed, Type, Name)%>%mutate(cluster=asignaciones)

#visualizar
ggplot(pok.clustered,aes(Attack, Total, color=Special.Attack, size=Speed))+
  geom_point()+
  geom_encircle(group=factor(asignaciones), spread=1e-2, expand=0.04)+
  geom_label_repel(label=pok$Name, max.overlaps = 15, alpha=0.6)
```
### Visualización del dendrograma con el corte

```{r}
library(dendextend)
dendrograma<-as.dendrogram(clusterpok2)
dendrograma_color<-color_branches(dendrograma, h=2.6)
plot(dendrograma_color)
```

### Contar los pokémons de cada tipo por cluster


#### Clúster 1

```{r}
cluster1 <- pok.clustered %>% filter(cluster==1)
glimpse(cluster1)
```


```{r}
cluster1 %>% count(Type, sort=T)
```


#### Clúster 2

```{r}
cluster2 <- pok.clustered %>% filter(cluster==2)
glimpse(cluster2)
```

```{r}
cluster2 %>% count(Type, sort=T)
```


#### Clúster 3

```{r}
cluster3 <- pok.clustered %>% filter(cluster==3)
glimpse(cluster3)
```

```{r}
cluster3 %>% count(Type, sort=T)
```


### Conclusión del análisis con clúster jerárquico basado en variables correlacionadas positivamente entre sí

Los pokémons en el clúster 3 tienen características que en general, comparados con los de los clústers 1 y 2 los hacen más fuertes, ambos son de tipo PSYCHIC.

Dentro del clúster 2 están la mayoría de los pokémons seleccionados y puede decirse que son pokémons fuertes pero no son los más fuertes de todos los elegidos, la mayoría de este grupo son de tipo DRAGON.

Por último, en el clúster 1 se encuentran los pokémons menos fuertes del grupo seleccionado (recordando: HP>100 y Total>550) y la mayoría son DRAGON o PSYCHIC.
